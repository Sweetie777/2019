数据结构

1. 复杂度 
    就是衡量算法好坏的一个刻度尺
	快/慢           ->  时间复杂度
	使用空间(内存)  ->  空间复杂度
	
2. 前提 : CPU每秒运行的指令数时恒定的
衡量算法快慢的标准是 算法运行的基本指令个数
数据规模n  运行指令个数f(n)和数据规模n有关
3. 大O渐进法 (1)只保留最高次项  (2)最高次项的系数化为1
4. 时间复杂度代表的不是绝对意义上的快慢, 代表的是, 随着数据规模的变化, 运行时间的变化趋势
5. 常见的时间复杂度
O(1)
O(log(n)) -> 二分查找
O(n)
O(n*log(n))
O(n^2)  冒泡排序
O(2^n)  递归 画框框数框框 (了解就行)

6. 空间复杂度 大O渐进法
   数据规模是n的情况下 
     1)额外使用的空间大小(不考虑输入输出中用到的空间)
	 2)常见形式
	   int[]array  = new int[]   []:和n的关系s
	
链表中的头结点有特殊性. 它没有前驱结点

interview
1. 删除链表中的所有value : 遍历链表中的所有结点, 如果不是要删除的结点, 尾插到result链表 (removeElements)
2. 逆置单链表 : 遍历所有结点, 头插到result链表上  (reverseList)
3. 合并两个链表 : 遍历两个链表, 哪个结点的值比较小, 就先放在result链表中, 当其中一个链表为空之后, 就把另一个链表跟在后面 (mergeTwoList)
4. 利用 x 把链表分成两条
5. 双引用遍历
求中间结点 : 快慢引用, 一个周期内, 一个走一步, 一个走两步, 谁先走需要模拟画图, 都需要null判定
倒数第k个引用 : 前后引用, 如果倒数第k个大于链表长度, 分情况讨论
6. 回文 : 逆置后半条链表, 然后进行一一比对
7. 删除重复 : p1和p2是进行比较的两个结点, 相等和不相等两种情况分情况讨论

1. 链表 : 插入删除更友好 ; 整体上说链表存储效率更高
2. 顺序表 : 随机访问o1时间复杂度; 单个数据存储, 存储效率更高; 
         不容易产生
3. 栈的应用: 改变次序(括号匹配; 中缀表达式求值 逆波兰表达式, 通过括号表达优先级; 暴力解迷宫)
4. 

面试题: 
1. 括号匹配: 遍历每个字符, 如果是左括号, 压栈; 
		  如果是右括号, 如果栈是你空的, 不匹配, 比较栈顶和这个右括号,匹配/不匹配
2. 		  
		  
二叉树: 1) 有序树, 最多有两个子节点		  
		2) 左子树+右子树 完全二叉树  满二叉树(特殊的完全二叉树)
		3) 前序, 中序, 后序
		   利用递归实现
		   
建立二叉树: 前序+中序 ok  中序+后序 ok
利用中序＋前序建立二叉树:
1. 在前序中找到根得值preorder[0]
2. 在中序中找到根得值所在得下标(就是左子树得结点的个数)
3. 切除左子树得前序＋中序
preorder 跳过1, 长度是下标
inorder 长度是下标
4. 切除右子树的前序
		  
如何创建二叉树 
1.利用带空结点的前序创建二叉树
难点: 递归的思路
递归过程中变化的只有参数
创建子树需要用到递归, 问题转化成 递归调用该函数创建子树时, 应该传入夫人参数是什么, 
如果利用现有条件, 找到两颗子树的带空结点的前序遍历		  


层序遍历  广度优先遍历(要用到队列)



static修饰方法 就是和对象脱离关系, 仅剩和类的关系
反射(reflection): 就是在运行期间, 拿着字符串
		 

二叉树总结: 
树型结构  vs  线型结构		
难点: 递归的思想 去找递归公式(找下一次递归函数调用的参数)  去找终止条件(根据参数变化,找到停止的位置)
理解递归函数调用, 全局的视角, 学会画调用栈