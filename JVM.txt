JVM
1. JVM运行时区域划分
线程私有
	程序计数器
	虚拟机栈: 描述Java方法的内存模型
	本地方法栈: 描述的是native方法
	在HotspotJVM中, 本地方法栈和虚拟机栈合二为一
线程共享
	GC堆: 所有对象实例及数组对象
	方法区: 已加载的类信息, 常量, 静态变量
	运行时常量池: 方法区的一部分,字面量和符号引用
		字面量: 直接写出来的值, 10  "abc"...
		符号引用: 

2. GC
	1)如何判断对象是否存活
		引用计数法: 无法解决循环引用问题(我中有你, 你中有我)
		无用对象仍然判断存活而无法回收, 所以JVM不使用此方法
	
		Java中采用可达性分析法
			通过一系列 GC Roots对象作为起点, 从这些节点开始向下搜索, 
			哪些对象可以作为GC Roots: 
							栈中引用的对象, 类中静态变量, 常量引用的对象
							
	****JDK1.2之后对引用的扩充****
		强: 程序中普遍存在的 , 类似于直接new的, 
			对象被任意一个强引用指向, 即使抛出OOM异常, 也无法回收被强引用指向的对象
		软: 描述有用但不必须的对象, SoftReference类描述软引用
			典型的就是 程序缓存
			生命周期: 若对象只被软引用指向, 当前内存够用时不回收, 但当抛出OOM异常时, 一次性回收所有仅被软引用指向的对象
		弱: 仅被弱引用指向的对象, 无论内存是否够用, 当gc开始时, 都会被回收掉
		虚: (PhantomReference)完全不对对象的生存周期产生任何影响, 也无法通过虚引用取得一个对象实例
			当虚引用指向的对象被GC时, JVM会发回一个回收通知
			
			
	2)对象的自我拯救finalize(JDK1.9 已经废弃)
		若对象所在的类覆写了finalize()
			1)该对象的finalize()未被JVM调用过, JVM会调用此对象的finalize()
			2)该对象的finalize()被JVM调用过, 此对象被标价为不再存活, 可以进行GC
		对象所在的类没有覆写finalize(), 此对象直接标记为不再存活, 可以进行GC
		
	3)垃圾回收算法
	将堆空间分为新生代和老年代, 对象默认在新生代产生,
	新生代对象的存活率很低(不足2%)
	Java采用分代回收算法, 新生代采用复制算法, 老年代采用标记-整理算法
		-Xss(设置栈的大小) 128k
		-Xms(设置堆的最小值) 10m
		-Xmx(设置堆的最大值)
		-Xmn(设置新生代内存大小
		
		新生代GC比老年代快10倍以上, 发生频率高的多
		为何老年代不采用复制算法: 
			老年代对象存活率很高, 采用复制算法, 开销远大于新生代
			.
3. JDK内置工具的使用
	jps jmap jstack
4. JMM
	volatile(可见性; 禁止指令重排 Double-Check-Singleton)
	
	禁止指令重排:
		1. volatile代码既不会提前也不会滞后
		2. volatile代码前的所有代码一定全部 执行完毕, volatile之后的代码一定还未开始
	
	
	